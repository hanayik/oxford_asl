#!/bin/bash

# TURQUAT: Turbo QUASAR ASL Bayesian Analysis Tool
#
# Moss Zhao, Michael Chappell, QUBIC Group, IBME, University of Oxford Image
#
# Copyright (c) 2018-2018 University of Oxford
#
# SHCOPYRIGHT

# Make script use local copies of helper scripts/programs in the same
# directory, if present. This allows for multiple versions of the scripts
# to be used, possibly with bundled dependencies
PATH=`dirname $0`:${FSLDEVDIR}/bin:${FSLDIR}/bin:${PATH}

abspath() {                                               
    # Return an absolute path if the input is relative
    cd "$(dirname "$1")"
    printf "%s/%s\n" "$(pwd)" "$(basename "$1")"
}

Usage() {
    # For future development, I have commented some potentially useful options
    echo "Turbo QUASAR ASL Bayesian Analysis Tool"
    echo "Beta version: it only works in AMC's file format:"
    echo "Shift 1 Repeat 1 Tag, Shift 1 Repeat 1 Control, Shift 2 Repeat 1 Tag, Shift 2 Repeat 1 Control."
    echo ""
    echo "Usage (optional parameters in {}):"
    echo "Example (healthy control): turquat -i XXX -o XXX --calib --corrcal"
    echo "Example (SCD patients): turquat -i XXX -o XXX --calib  --corrcal --tau --infertau"
    echo " -i         : specify data file"
    echo " {-o}       : specify output directory"
    echo " {-m}       : specify brain mask file"
    echo ""
    echo " Extended options:"
    echo " --calib    : include a calibration image (this will automatically tigger the --trans option)"
    echo " --transoff : transform the calibration image to the current data resolution"
    echo " --t1b      : Set the value for T1 of arterial blood {default: 1.6 s}"
    echo " --corrcal  : Correct partial volume effects on the edge of calibration image M0a"
    echo " --infertau : estimate bolus duration from data"
    # Future development
    #echo " --disp     : include bolus dispersion in the model (gamma kernel)"
    # Future development
    #echo " --mfree    : Do model-free (SVD deconvolution) analysis"
    # Future development of partial volume correction options
    #echo ""
    #echo " Partial volume effects correction options:"
    #echo " --pvcorr   : Set partial volume effect correction on. You should provide high resolution partial volume estimates and a structural image."
    #echo " --fslanat  : Name of the directory containing the output from fsl_anat"
    #echo " --t1wm     : T1 for WM {default: 1.1 s}"
    #echo ""
    echo " Sequence parameters:"
    echo " --tau      : Set bolus duration {default: 0.6 s}"
    echo " --slicedt  : Set the increase in TI with slice {default: 0.035 s}"
    echo " --alpha    : Inversion efficiency {default: 0.91}"
    echo " --lambda   : Blood-water coefficient factor {default: 0.9}"
    echo " --fa       : Flip angle for LL readout {default: 35 degrees}"
    echo " --lfa      : Lower flip angle for final phase of data {default: 11.7 degrees}"
    echo " --tis      : comma separated list of TI values"
    echo "            {default: 0.04,0.64,1.24,1.84,2.44,3.04,3.64,4.24,4.84,5.44,6.04}"
    echo " --shift    : slice shifting factor {default: 1}"
    echo " --break_1  : slice number of first acquisition point (start from 0) {default: 0}"
    echo " --break_2  : slice number of middle acquisition point (start from 0) {default: 7}"
    echo " --break_3  : slice number of last acquisition point (start from 0) {default: 14}"
    echo " --taupat   : comma separated list of bolus pattern. 1: label, 0: skip"
    echo "            {default: 1, 1, 1, 1, 1, 1, 1}"
    echo ""
}

Version() {
echo "@GIT_SHA1@ @GIT_DATE@"
exit 0
}

# deal with options
if [ -z $1 ]; then
    Usage
    exit 1
fi

until [ -z $1 ]; do

    # look at this option and determine if has an argument specified by an =
    option=`echo $1 | sed s/=.*//`
    arg="" #specifies if an argument is to be read from next item on command line (=1 is is when = is used)

    if [ $option = $1 ]; then
    # no argument to this command has been found with it (i.e. after an =)
    # if there is an argument it will be the next option
        argument=$2
    else
        arg=1
        argument=`echo $1 | sed s/.*=//`
    fi
    takeargs=0;boolarg="";isbool="";

        case $option in
        -o) outflag=1 outdir=$argument
            shift;;
        -i) inflag=1 infile=$argument #input/data file
            shift;;
        -m) mask=$argument
            shift;;
        --t1b) t1b=$argument
            shift;;
        --t1) t1=$argument
            shift;;
        --t1wm) t1wm=$argument
            shift;;
        --slicedt) slicedt=$argument
            shift;;
        --fa) fa=$argument
            shift;;
        --lfa) lfa=$argument
            shift;;
        --shift) shift_factor=$argument
            shift;;
        --break_1) break_1=$argument
            shift;;
        --break_2) break_2=$argument
            shift;;
        --break_3) break_3=$argument
            shift;;
        #--disp) disp=1
        #    ;;
        #--mfree) mfree=1
        #    ;;
        #--edgecorr) isbool=1;
        #	boolarg=edgecorr;
    	#	;;
        --tis) tis=$argument
            shift;;
        #--iform) iform=$argument # to choose the input form of the data
        #    shift;;
        --tau) tau=$argument
            shift;;
        --corrcal) corrcal=1
            ;;
        --alpha) alpha=$argument
            shift;;
        --lambda) lambda=$argument
            shift;;
        --infertau) infertau=1
            ;;

        --pvcorr) pvcorr=1
            ;;
        #--pvgm) pvgm_highres=$argument
            #shift;;
        #--pvwm) pvwm_highres=$argument
            #shift;;
        #--s) strim=$argument # structure images for registration and partial volume estimation
            #shift;;
        #--fslanat) fslanat=$argument # Directory containing the output from fsl_anat
        #    shift;;

        --ccmds) calibcmds=$argument
            shift;;
        --debug) debug=1 #debugging option
            ;;
        --version) Version
            ;;
        *)  Usage
            echo "Error! Unrecognised option on command line: $1"
            echo ""
            exit 1;;
        esac

        # sort out a shift required by a command line option that takes arguments
        if [ -z $arg ]; then
        	# an argument has been supplied on the command NOT using an =
        	if [ $takeargs -eq 1 ]; then
        	    shift;
        	fi
        fi
        
        if [ ! -z $isbool ]; then
    	    # this is an (explicit) boolean setting
        	if [ ! -z $arg ]; then
        	    # an argument has been supplied on the command using an =
        	    # set the variable based on the argument
        	    case $argument in
        		on) eval $boolarg=1
        		    ;;
        		off) eval $boolarg=""
        		     ;;
        		1) eval $boolarg=1
        		   ;;
        		0) eval $boolarg=""
        		   ;;
        		*)  Usage
        		    echo "Error! Unrecognised setting for boolean option: $1"
        		    echo ""
        		    exit 1;;
        	    esac
        	else
        	    # no argument has been suppled with this command (NOTE that you cannot supply an arugment to a bool option without an =)
        	    # this sets the variable to true
        	    eval $boolarg=1;
        	fi
        fi

        shift
done

#### --- Procedural ---
asl_file=asl_file
fabber=fabber_asl
asl_mfree=asl_mfree ###~/cproject/asl_mfree/asl_mfree

#### --- Housekeeping ---
# set the output directory here if not specified
if [ -z $outflag ]; then
    echo "Ouput being placed in basil subdirectory of input directory"
    outdir=$indir/quasil;
fi

# Start by looking for the output directory (and create if need be)
count=0
while [ -d $outdir ]; do
    outdir=$outdir"+"
    count=`expr $count + 1`

    if [ $count -gt 20 ]; then
    echo "Error: $outdir too many existing output directories (i.e. shall not add another +)"
    exit
    fi
done
echo "Creating output directory: $outdir"
mkdir $outdir;

# save the starting directory
stdir=`pwd`

# Full path of output directory
outdir=$(abspath $outdir)

# make a temp directory to work in
tmpbase=`tmpnam`
tmpbase="haha"
tempdir=${tmpbase}_turquat
mkdir $tempdir

# deal with the TIs
if [ -z $tis ]; then
    # default QUASAR list of TIs
    tis="0.04,0.64,1.24,1.84,2.44,3.04,3.64,4.24,4.84,5.44,6.04"
fi

# deal with bolus patterns
if [ -z $taupat ]; then
    # default QUASAR list of TIs
    taupat="1,1,1,1,1,1,1"
fi

# Create TI list
count=0
tislist=""
thetis=`echo $tis | sed 's:,: :g'`
for ti in $thetis; do
    count=`expr ${count} + 1`
    tislist=`echo $tislist --ti${count}=$ti`
done
# echo "TIs list: $tislist" >> $log
ntis=$count;


# Create bolus pattern list
count=0
taulist=""
thetaus=`echo $taupat | sed 's:,: :g'`
for current_taupat in $thetaus; do
    count=`expr ${count} + 1`
    bolus_pattern_list=`echo $bolus_pattern_list --bolus_${count}=$current_taupat`
done
# echo "bolus pattern list: $bolus_pattern_list" >> $log
ntis=$count;


if [ -z $iform ]; then
    iform="q"
fi

# parameters
#bolus duration - default 0.64 s
if [ -z $tau ]; then
tau=0.6;
fi

#T1b
if [ -z $t1b ]; then
t1b=1.6;
fi

#T1 - this si the prior value, since T1 will be estimated from the data
if [ -z $t1 ]; then
t1=1.3;
fi

#T1WM
if [ -z $t1wm ]; then
    t1wm=1.1;
fi

# sequence parameters
# slicedt
if [ -z $slicedt ]; then
    slicedt=0.036;
fi
# Flip angles
if [ -z $fa ]; then
    fa=35;
fi
if [ -z $lfa ]; then
    lfa=11.7;
fi
if [ -z $alpha ]; then
    alpha=0.91;
fi
if [ -z $lambda ]; then
    alpha=0.9;
fi


if [ -z $break_1 ]; then
    break_1=0;
    break_1_result=$break_1;
fi
if [ -z $break_2 ]; then
    break_2=7;
    break_2_result=`expr $break_2 + 1`;
fi
if [ -z $break_3 ]; then
    break_3=14;
    break_3_result=$break_3;
fi

# Compute segment length
segment_1_length=count=`expr $break_2 - $break_1`
segment_2_length=count=`expr $break_3 - $break_2 + 1`
segment_1_length_result=`expr $break_2_result - $break_1_result`
segment_2_length_result=`expr $break_3_result - $break_2_result - 1`


#### --- Pre-processing ---
echo "Pre-processing"
imcp $infile $tempdir/data

#if [ ! -z $fslanat ]; then
#    cp -R $fslanat $tempdir
#fi

cd $tempdir
# Re-arrange the file
# Split the input file into different repeats and shifts
shift_1_repeat_1_tag="shift_1_repeat_1_tag"
shift_1_repeat_1_control="shift_1_repeat_1_control"
shift_2_repeat_1_tag="shift_2_repeat_1_tag"
shift_2_repeat_1_control="shift_2_repeat_1_control"

shift_2_repeat_1_control_effective="shift_2_repeat_1_control_effective"
shift_2_repeat_1_tag_effective="shift_2_repeat_1_tag_effective"
shift_2_repeat_1_diff_effective="shift_2_repeat_1_diff_effective"

fslroi data $shift_1_repeat_1_tag 0 77
fslroi data $shift_1_repeat_1_control 77 77
fslroi data $shift_2_repeat_1_tag 154 77
fslroi data $shift_2_repeat_1_control 231 77

# Create a mask for the whole data. We use shift 1 repeat 1 control data
if [ -z $mask ]; then
# auto generate mask
    fslmaths $shift_1_repeat_1_control -Tmean aslmean
    bet aslmean mask
    fslmaths mask -bin mask
else
    cd $stdir
    imcp $mask $tempdir/mask
    cd $tempdir
fi

# copy mask to output for future reference
cd $stdir
imcp $tempdir/mask $outdir/mask
cd $tempdir

# Rearrange the slices for shift 2
# Do control image first
# Shift 2 We need to split and rearrange the z direction
fslroi $shift_2_repeat_1_control data_segment_1 0 64 0 64 $break_1 $segment_1_length
fslroi $shift_2_repeat_1_control data_segment_2 0 64 0 64 $break_2 $segment_2_length
fslmerge -z $shift_2_repeat_1_control_effective data_segment_2 data_segment_1 # Segment 2 was scanned first   

fslroi $shift_2_repeat_1_tag data_segment_1 0 64 0 64 $break_1 $segment_1_length
fslroi $shift_2_repeat_1_tag data_segment_2 0 64 0 64 $break_2 $segment_2_length
fslmerge -z $shift_2_repeat_1_tag_effective data_segment_2 data_segment_1 # Segment 2 was scanned first 
